; RANDOM

to-report topk-random
  let topk [self] of turtles with [document?]
  report smart-sublist topk max-k
end



to-report topk-rememberRandom [active-turtle k memory-list]
  let topk [self] of turtles with [document?]
  foreach topk [if (member? ? link-neighbors or member? ? memory-list) [set topk remove ? topk]]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end

;PEER SIMILARITY
to-report topk-peerSimilarity
  let friends [self] of out-link-neighbors with [not document?]
  let topk []
  let docs []
  
  ask turtles with [document?] [
    set pov-score 0  
    set docs lput self docs
  ]
  
  ;for every friend
  ask turtle-set friends [    
    ;for every liked document
    ask out-link-neighbors with [document?] [
      ;add to list, or increase its score 
      set docs lput self docs set pov-score 1
    ]
  ]
  
  ;Destroy duplicates
  foreach topk [if (member? ? out-link-neighbors or member? ? topk-memory) [set topk remove ? topk]]
  
  ;Sort docs by their pov-score
  set topk reverse sort-on [pov-score] turtle-set docs
  
  report smart-sublist topk max-k
end



;PEER SIMILARITY - corrected
to-report topk-peerSimilarity2
  let friends [self] of out-link-neighbors with [not document?]
  let topk []
  let docs []
  
  ask turtles with [document?] [
    set pov-score 0  
    set docs lput self docs
  ]
  
  ;for every friend
  ask turtle-set friends [    
    ;for every liked document
    ask out-link-neighbors with [document?] [
      ;add to list, or increase its score 
      set docs lput self docs set pov-score 1
    ]
  ]
  
  show topk-memory
  ;Destroy duplicates
  foreach docs [
    if (member? ? out-link-neighbors) or (member? ? topk-memory)[set docs remove ? docs]
  ]

  ;Sort docs by their pov-score
  set topk reverse sort-on [pov-score] turtle-set docs
  
  report smart-sublist topk max-k
end
