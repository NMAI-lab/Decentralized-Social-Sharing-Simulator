
to-report topk-popularity [active-turtle k]
  ;; Sort documents by how many links they have
  let topk reverse sort-on [count link-neighbors] turtles with [document?]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end


to-report topk-random [active-turtle k]
  let topk [self] of turtles with [document?]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end


to-report topk-newPopularity [active-turtle k]
  let topk reverse sort-on [count link-neighbors] turtles with [document?]
  foreach topk [if (member? ? link-neighbors) [set topk remove ? topk]]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end


to-report topk-newRandom [active-turtle k]
  let topk [self] of turtles with [document?]
  foreach topk [if (member? ? link-neighbors) [set topk remove ? topk]]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end


to-report topk-rememberPopularity [active-turtle k memory-list]
  let topk reverse sort-on [count link-neighbors] turtles with [document?]
  show link-neighbors
  foreach topk [if (member? ? link-neighbors or member? ? memory-list) [set topk remove ? topk]]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end

to-report topk-rememberRandom [active-turtle k memory-list]
  let topk [self] of turtles with [document?]
  foreach topk [if (member? ? link-neighbors or member? ? memory-list) [set topk remove ? topk]]
  
  if (length topk > k) [set topk sublist topk 0 k]
  report topk
end

to-report topk-peerSimilarity [active-turtle k]
  let peers [self] of out-link-neighbors with [not document?]
  let topk []
  
  foreach peers [
    let docs []
    ask ? [set docs [self] of out-link-neighbors with [document?]]
    
    foreach docs [
      if (not member? ? topk) [set topk lput ? topk]
    ]
  ]
  
  if length topk = 0 [set topk topk-random active-turtle k]
    
  report smart-sublist topk k
end